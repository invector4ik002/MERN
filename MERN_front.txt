И так любимый фронт ======================================================================================================
1. После того как поставили БЭК прописали проверки авторизаций подключились к Базе Данных MongoDB
2. Установили npm i create-react-app
   2.1 убрали все лишнее из стандартного набора
   2.2 Донастройки (package.json) прописали "script" для запуска двух серверов(скриптов) ,один для запуска ФРОНТА второй для БЭКА
      используем пакет "concurrently": "^5.1.0",
     2.2.1 "dev": "concurrently \"npm run server\" \"npm run client\"" был момент с ошибкой из за пробела 
      его не была \"npm run server\"тут нужен пробел\"npm run client\""
     2.2.2 "client": "npm run start --prefix client", для запуска сервера (--prefix client) React приложения из папки MERN 
===============================================================================================================================
Вот сейчас приступаем к созданию формы .
1. Для разработки синглПэйджАпликатион нам понадобится система маршрутизации , ее подключим библиотекой React 
   npm i react-router-dom Так как это приложение на отдельном сервере и имеет свои зависимости все ставим в паку 
   "C:\GitHub\MERN\client>npm i react-router-dom" ! 
*! Что бы запускать сервера нужно выходить из C:\GitHub\MERN\client> в C:\GitHub\MERN\
-----------------------------------------------------------------------------------------------------------------------
2. Создаем директорию/папку "pages" где будут хрониться страницы для нашего приложения 
  2.1 Создаем страничку AuthPage.js страница авторизации
  2.2 Создаем страничку LinksPage.js страница ссылочек которые есть у пользователя
  2.3 Создаем страничку CreatePage.js страница для создания ссылок (сокращенных о_о проесним)
  2.4 Создаем страничку DetailPages.js страница показывающая конкретную ссылку и статистику по ней
----------------------------------------------------------------------------------------------------------------------
3. Создаем фаил для роутинга "routes.js" в папке "src/routes.js" для оприделения всех наборов ссылок
 3.1 Теперь когда роуты прописаны для user аторизованного и нет в компоненте App прописываем логику
  const routes = useRoutes(false); false условно пока не в системе (заглушка) если менять на (true)
  тогда можно эмитировать переходы между компонентами, своего рода прозвонка.
 3.2 Для того что бы все роуты подключить к единому приложению требуется все обернуть в метод
   import { BrowserRouter as Router} from 'react-router-dom'; переназываем в as Router
 3.3 Масс верстка :)
 3.4 Логика через хуки useState импорт его итд 
   const [form, setForm] = useState({ email: '', password: '' }) изначальный стейт

   const changeHandler = (event) => { Это функция для получения данных из импутов. этоу функцию помещаем в каждый <input>
      по событию onChange={changeHandler}
      setForm({ ...form, [event.target.name]: event.target.value}) ...form, открываем изначальный стейт весть тоесть
      все поля email и password 
      для внесения данных из <input> используем события по target(цель,нацеливание)
      [event.target.name]: по name(атрибутов input) получаем и вписываем(сохраняем) из события из значений event.target.value
      таким образом перезаписываем занчение стейта на то что пришло в <input>
   } 
-----------------------------------------------------------------------------------------------------------------------------
**** Функция для регистрации ****
const registerHandler = async () => {
      try {
         const data = await request('/api/auth/register', 'POST', { ...form }) '/api/auth/register', пишется так целиком
      } catch (err) { // обработана в кастомном хуке useHttp

      }
   }

Привязка к кнопке естественно

<button 
   className="btn grey lighten-1 black-text"
   onClick={registerHandler}
   disabled={loading}
   >
   Регистрация
</button>

**** Функция для входа после регистрации ****

const loginHandler = async () => {
      try {
         const data = await request('/api/auth/login', 'POST', { ...form })
         console.log('AuthPage.js: Data >',data)
         // message(data.message)
      } catch (err) {

      }
   }

Привязка к кнопке естественно

<button 
   className="btn yellow darken-4" 
   style={{marginRight: 10}}
   onClick={loginHandler}
   disabled={loading}
   >
   Войти
</button>

-----------------------------------------------------------------------------------------------------------------------------
4. Кастомные хуки. 
 4.1 сздаем дерикторию/папку "hooks" в корне "src/hooks" 
------------------------------------------------------------------------------------------------------------------------------
 4.2 создаем файл для создания кастомного хука "httphook.js"
   для работы с асинхронными запросами на сервер используя нативный api браузера fetch в формате хуков

import {useState, useCallback} from 'react'; // импортируем стандартые хуки React

export const useHttp = () => {  // експортируем наш кастом что бы можно было его принять где нам удобно
   const [loading, setLoading] = useState(false); // хук состояния отображает состояния loading(загрузка)
   const [error, setError] = useState(null); // хук состояния ошибки

   const request = useCallback( async (url, method = 'GET', body = null, headers = {}) => {
      setLoading(true);
      try {
         const response = await fetch(url, {method, body, headers}) // названия совпадают со стандартным api
         const data = await response.json(); // пришедшие данные из браузера приводим в формат json и сохраняем в переменную data

         if(!response.ok) { // если респонс содержит ошибку тогда выброс ошибки  throw new Error
            throw new Error(data.message || 'Ошибка http.hook.js')// если есть поле message в date то увидем ошибку оттуда
         }

         setLoading(false)

         return data

      } catch (err) { // если try не отрабатывает тогда 
         setLoading(false) // лоадинг не лоадинг :)
         setError(err.message) // сет еррор меняет состояние на err.message(ошибка с сообщением) 
         throw err выброс ошибки
      }
   }, []); // тута нужны зависимости

   const clearError = () => setError(null) // чистит ошибки обнуляется состояние хука состояния ошибок

   return { loading, request, error, clearError } кстомный хук возвращает все это :)
}
импортировали в AuthPage.js // страница/авторизации передали {loading, request, error}

4.3 Создаем хук авторизации---------------------------------------------
 Хук содержащий методы для входа и выхода из системы 
 Работа вторизации в заимодействии с jwtToken если мы получаем токен то его нужно хранить в локал сторадже 
 Если человек перезапустил браузер и в его локал сторадже есть Token то юзер попадает сразу в систему 

import { useState, useCallback, useEffect } from 'react';

const storageName = 'userData'; // имя хранилища

export const useAuth = () => { // кастомный хук для работы с подключением и отключеним системы
   const [token, setToken] = useState(null); // локальные состояния
   const [userId, setUserId] = useState(null); // локальные состояния

   const login = useCallback( (jwtToken, id) => { // фуекция для логирования в браузере 
      setToken(jwtToken); // изменили состояние(null) token на токен
      setUserId(id); // изменили состояние(null) id на id

      localStorage.setItem(storageName, JSON.stringify({ // базовый браузерный api(вроде метода) сохранили в локальное хранилище
         userId, // получили с сервера
         token // получили с сервера
      })); 

   }, []);

   const logout = useCallback( () => { // функция для разлогирования
      setToken(null); // обнуление состояния token
      setUserId(null); // обнуление состояния userId
      localStorage.removeItem(storageName); // обнуление в локальном хранилище
   }, []);
   
   useEffect( () => {
      const data = JSON.parse(localStorage.getItem(storageName)); // преобразуем в обьект то что получили из getItem по ключу storageName

      if (data && data.token) { // если data не null и в data есть поле token
         login(data.token, data.userId); // при проверке в true запусаем функцию с параметрами из локального хранилища тем самым 
      }                                  // при логине useEffect срабатывает и постоянно видит login до время жизни token(1h)

   }, [login]); // зависимость для запуска useEffect

   return { login, logout, token, userId };// кастомный хук возврощается с функционалом login, logout и полями с текущим состоянием token, userId
};
далее идем в App.json
---------------------------------------------------------------------------------------------------------------------------
5. Создание контекста для передачи property всему приложению НЕ ПО ДРЕВОВИДНОЙ СТУКУРЕ
  5.1 создается дериктория/папка "context"

import { createContext } from 'react'; // создаем конекст при помощи спец.функции createContext

function noop() {} // не понял я зачем это :)

export const AuthContext = createContext({ // создаем контекст тоесть обьект изночальных значений полей для импорта во все приложение
   token: null, // токен нашего пользователя иночально (null)
   userId: null, // id нашего пользователя изначально (null)
   login: noop, // залогинен ДОШЛО ЗАЧЕМ(не понял я зачем это) из кастомного хука прилетает рабочая функция и заменяет эту! 
   logout: noop, // разлогинен ДОШЛО ЗАЧЕМ(не понял я зачем это) из кастомного хука прилетает рабочая функция и заменяет эту!
   isAuthenticated: false // Аутентифицировано (false) то есть изночально не залогинен
});
уходим в App.js
---------------------------------------------------------------------------------------------------------------------------
6. Создаем фаил в директории "routes" link.routes.js вопрос зачем :)
 идея этого роута заключается в сокращении ссылок хмммм
 6.1 далее для этого создается модель! в директории "models" Link.js
Переходим в routes/link.routes.js
 6.2 Создаем логику файла link.routes.js (это называется мидлвер) и его нужно подключить в MERN/app.js
  Логика такова в ней мы при запросах на сервер получаем данные в нашем случае этого мидлвара получаем ссылки по id пользователя 
  один запрос при условии того что зарегистрирован пользователь 
6.3 Создаем мидлвар для расшифровки токена для того что бы использовать его для привязки ссылок, переходим в link.routes.js
 подключаем мидлварРасшифровщик 
   /**
 * @param{auth} - в переменной auth заложана логика расшифровки токена в котором есть нужное поле userId 
 */
router.get('/', auth, async (req, res) => { // гет запрос для получения всех ссылок и возвращают их
 6.4 для сокращения ссылок используется библиотека npm i shortid используем ее  
  
---------------------------------------------------------------------------------------------------------------------------
*!!! ПРОБНЫЙ ЗАПУСК ОШИБКИ 
POST http://localhost:3000/api/auth/register 404 (Not Found) ошибка возникла из за того что запрос ушел на сервер 
:3000 нам нужен порт :4000 
Для этого в package.json(директории/папки "client") ДОБАВЛЯЕМ поле "proxy": "http://localhost:4000" запускаем npm run dev
БЛЯТЬ ОПЯТЬ ОШИБКА http.hook.js:10 POST http://localhost:3000/api/auth/register 400 (Bad Request)
Некорректные данные при вводе вводил все корректно ...разбор 
 http://localhost:3000 обратим внимание что указан 3000 но это вроде норм так как прокси перекидывает на :4000
Так как ошибка связана с сервером
ставим прослушку на входящие данные 

   *ВНИМАНИЕ! node так устроена что body она воспринемает как стримы (я так понял body c браузера)
   для решения подобной задачи нужен мидлвер в основной серверный файл app.js
   app.use(express.json({ extended: true })); мидлвар для понимания body 
   теперь вывод консоли показывает auth.routes: body > {}


  router.post('/register', 
   [
      check('email', 'Некорректный email').isEmail(),
      check('password', 'Минимальная длинна пароля 6 символов').isLength({ min: 6 })
   ],
   async (req, res) => {
      console.log('auth.routes: body >', req.body) ЛОВИМ ТУТ ВЫВОД В КОНСОЛЬ СЕРВЕРА auth.routes: body > undefined
   try {
     const errors = validationResult(req);
      if(!errors.isEmpty()) {
         return res.status(400).json({ 
            errors: errors.array(),
            message: 'Некорректные данные при регистрации'
         })
      }
Ошибки продолжаются теперь в хроме получаем корректные данные а на сервере все еще пустой объект
 эта проблема связяна с тем что мы должны указывать что по сути мы передаем JSON c браузера нашим 
 кастомным хуком это делается СПЕЦИАЛЬНЫМ обьектом. headers['Content-Type'] = 'application/json'

 const request = useCallback( async (url, method = 'GET', body = null, headers = {}) => {
      setLoading(true);
      try {

         if (body) {
            body = JSON.stringify(body)
            headers['Content-Type'] = 'application/json'
         }
Вроде решена ошибка объект с данными пользователя ушел на БД 
(была проблема в настройках прав пользователя на mongoDB) после правильной настройки все работает .